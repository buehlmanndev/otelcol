receivers:
  filelog:
    include:
      - /var/log/pods/*/*/*.log
    start_at: beginning
    include_file_path: true
    operators:
      # Capture CRI timestamp before stripping envelope
      - id: capture_cri_timestamp
        type: regex_parser
        parse_from: body
        parse_to: attributes
        regex: '^(?P<paas_time_utc>\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d+Z)'
        on_error: drop

      # Strip containerd envelope and keep filepath metadata
      - id: container_cri
        type: container
        format: containerd
        add_metadata_from_filepath: true

      # Derive k8s metadata from file path
      - id: parse_pod_path
        type: regex_parser
        parse_from: attributes["log.file.path"]
        parse_to: attributes.k8s
        regex: '^/var/log/pods/(?P<namespace>[^_]+)_(?P<pod_name>[^_]+)_(?P<pod_uid>[^/]+)/(?P<container_name>[^._]+)/(?P<restart_count>\d+)\.log$'
        on_error: drop

      - id: copy_namespace_for_expected
        type: copy
        from: attributes["k8s.namespace.name"]
        to: attributes.namespace
        if: attributes["k8s.namespace.name"] != nil

      # Route by structure: JSON vs KV
      - id: log_router
        type: router
        default: kv_parse
        routes:
          - expr: 'body matches "^\\s*\\{"'
            output: json_parse

      # JSON route: parse and flatten
      - id: json_parse
        type: json_parser
        parse_from: body
        parse_to: attributes
        on_error: drop
        output: json_move_message

      - id: json_move_message
        type: move
        from: attributes.message
        to: body
        if: 'attributes.message != nil'
        output: json_flatten_log_level

      - id: json_flatten_log_level
        type: move
        from: attributes.log.level
        to: attributes["log.level"]
        if: 'attributes.log != nil && attributes.log.level != nil'
        output: cleanup_logtag

      # KV route: parse attributes, keep body untouched
      - id: kv_parse
        type: key_value_parser
        parse_from: body
        parse_to: attributes
        delimiter: "="
        pair_delimiter: ";"
        on_error: drop
        output: kv_trim_sev

      - id: kv_trim_sev
        type: regex_replace
        field: attributes.sev
        regex: "\\s+"
        replace_with: ""
        if: 'attributes.sev != nil'
        output: kv_strip_msg

      - id: kv_strip_msg
        type: regex_replace
        field: attributes.msg
        regex: '^\"|\"$'
        replace_with: ""
        if: 'attributes.msg != nil'
        output: cleanup_logtag

      # Minimal cleanup: remove helper fields
      - id: cleanup_logtag
        type: remove
        field: attributes.logtag
        if: 'attributes.logtag != nil'
        output: cleanup_log_iostream

      - id: cleanup_log_iostream
        type: remove
        field: attributes["log.iostream"]
        if: 'attributes["log.iostream"] != nil'
        output: cleanup_message_attribute

      - id: cleanup_message_attribute
        type: remove
        field: attributes.message
        if: 'attributes.message != nil'
        output: cleanup_msg_attribute

      - id: cleanup_msg_attribute
        type: remove
        field: attributes.msg
        if: 'attributes.msg != nil'

processors:
  batch: {}

exporters:
  file:
    path: /output/logs.json
  splunk_hec:
    endpoint: ${SPLUNK_HEC_URL}
    token: ${SPLUNK_HEC_TOKEN}
    disable_compression: true
    source: "otelcol"

service:
  pipelines:
    logs:
      receivers: [filelog]
      processors: [batch]
      exporters: [file, splunk_hec]
